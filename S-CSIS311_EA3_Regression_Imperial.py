# -*- coding: utf-8 -*-
"""S-CSIS311_EA3_Regression_Imperial.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1HmEemSegObEs41U5gyIobq6zkgPZEnqN

*De La Salle University – Dasmariñas*  
*College of Information and Computer Studies*

*S-CSIS311 / S-CSIS311LA*  
*Introduction to Machine Learning*

*Enabling Assessment: Regression*  
*Wednesday, September 11, 2024*

__Luis Anton P. Imperial__  
__BCS32__

# Enabling Assessment – Regression

## Learning Outcome:
1. Students will be able to explain the basic concept of linear regression.
2. Students will be able to build a simple regression model in Google Colab.
3. Students will be able to use Google Colab to visualize key metrics.

## Direction:
Using Anaconda or Google Colab, solve the machine problem. Evaluate, analyze, and explain the steps using your chosen tool. Use the dataset housing. After completing the solution, create two copies: one in PDF format and one in Python (.py) format. Submit both files to the folder provided in MS Teams.

## Steps:
1. Import the libraries
2. Load the data
3. Setup the data
4. Prepare the data processing
5. Train the model
6. Test the model
7. Print the predictions
8. Visualize the model

## Objective:
To predict the Median House Value based on Median Income
"""

# Importing libraries required
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
from sklearn import datasets, linear_model
from sklearn.metrics import mean_squared_error, r2_score

SEED = 42
np.random.seed(SEED)

"""## Questions:
1. Load the dataset
2. Load the data frame.head()
3. Load the df = df[['median_income', 'median_house_value']]
4. Display dataframe information using df.info() and display df.head(10)
5. What values do you see?
6. What distributions do you see?
7. What relationships do you see?
8. What relationships do you think might benefit the prediction problem?
9. What ideas about the domain does the data spark?
10. Display all columns, head, tail and info using df.columns, df.head(), df.tail() and df.info()
11. Get an overall sense of the data shape using df.describe()
12. Group the data and sort in ascending order
13. Plot the data using scatterplot
14. Removing outliers
15. Visualize the trained model

"""

#### 1. Load the dataset
from google.colab import drive
drive.mount('/content/drive')
url = '/content/drive/MyDrive/Documents/Reference Documents/BCS3 CSIS311 Reference Documents/Supplementary BCS3 CSIS311 Reference Documents/housing.csv'

#### 2. Load the data frame.head()
df = pd.read_csv(url)
df.head()

"""### (2/15) Loading the dataset

As we can see from the previous code block, we have properly loaded the Comma-Separated Values (CSV) file we will rely on as our dataset.

The `head()` function of the Pandas package displays the "head", meaning the first few rows, of a given dataset. It is often used to test for the program's access to the data.
"""

#### 3. Load the df = df[['median_income', 'median_house_value']]
df = df[['median_income', 'median_house_value']]

#### 4. Display dataframe information using df.info() and display df.head(10)
df.info()
df.head(10)

"""### (5/15) Peeking through people's houses

5. What values do you see?
6. What distributions do you see?
7. What relationships do you see?
8. What relationships do you think might benefit the prediction problem?
9. What ideas about the domain does the data spark?

The values provided are the median income and the median house value in each of the first ten (out of 20,640) households in the dataset.

The distribution would be somewhat of a straight line going from bottom-left to top-right, considering that a glance of the dataset's head gives the impression of a positive correlation between a neighborhood's median income and the home's median value.

Perhaps the relationships that can be formed are one-to-many and one-to-one. The median housing value can rise not just because it is located in a neighborhood with higher-income residents; it can also rise depending on other statistics such as its proximity to a body of water.

I believe one-to-many relationships that also include other factors such as the median age of the houses in each area, as well as the total number of rooms each house can provide, can help predict the value of newly built and planned houses.

In simpler terms, the data suggests that the richer the family, the more expensive their house can get. *Sounds like a fairly understood overview, isn't it?*

10. Display all columns, head, tail and info using df.columns, df.head(), df.tail() and df.info()
11. Get an overall sense of the data shape using df.describe()
"""

#### 10. Display all columns, head, tail and info using df.columns, df.head(), df.tail() and df.info()
df = pd.read_csv(url)

df.columns
df.head()
df.tail()
df.info()

#### 11. Get an overall sense of the data shape using df.describe()
df.describe()

##### This will show only features that have nonzero missing values.
df_na = df.isna().sum()
df_na

##### Limit to categorical data using df.select_dtypes()
df_cat = df.select_dtypes(include=['object'])
df_cat.nunique()

##### Limit to numerical data df.select_dtypes()
df_num = df.select_dtypes(include=['number'])
df_num.nunique()

##### Look at correlations in the numerical independent variables as well as the dependent variables by executing df_num.corr()
df_num.corr()

#### 12. Group the data and sort in ascending order
df.groupby(by='median_house_value').count().sort_values('median_house_value', ascending=False).head(10)

#### 13. Plot the data using scatterplot
_ = df.plot.scatter('median_income', 'median_house_value')

_ = sns.boxplot(y='median_house_value', data=df)

_ = sns.violinplot(y='median_house_value', data=df)

_ = sns.jointplot(x="median_income", y="median_house_value", data=df, kind="reg")

#### 14. Removing outliers
df.drop(df[df['median_house_value']>500000].index, inplace=True)

_ = sns.violinplot(y='median_house_value', data=df)

_ = sns.jointplot(x="median_income", y="median_house_value", data=df, kind="reg")

"""##### Preparing the data for training and testing

1. Divide our independent and dependent variable into two separate variables.
2. Split the data into training and testing datasets.
"""

# 1)

X = df.iloc[:,8].values.reshape(-1,1) # input
y = df.iloc[:,7].values # output (dependent variable)

# 2) Splitting our data into training and testing sets
from sklearn.model_selection import train_test_split

X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, shuffle=False, random_state=SEED)

"""##### Train the Model"""

# Import the linear regression algorithm
from sklearn.linear_model import LinearRegression

regressor = LinearRegression()

# Train the model
regressor.fit(X_train, y_train)

"""#### 15. Visualize the trained model"""

# y=mx+c (Linear regression model)
line = regressor.coef_*X + regressor.intercept_

# Lets plot this on the scatter plot
plt.scatter(X,y)
plt.plot(X, line, 'r')
plt.xlabel("Median House Value")
plt.ylabel("Median Income")
plt.title("Median House Value vs Median Income")
plt.show()

"""## Rubrics:

Criteria | Scoring
-----|-----
Data Preprocessing | 20 pts.
Training Performance | 20 pts.
Model Evaluation Metrics | 20 pts.
Visualization | 20 pts.
Explanation & Analysis | 20 pts.
"""

